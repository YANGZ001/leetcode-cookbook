# LeetCode Link

[Count of Smaller Numbers After Self - LeetCode](https://leetcode.com/problems/count-of-smaller-numbers-after-self/)

# Idea

Looks like a monotone stack could solve this question.

# Code

```java
class Solution {
    private class Element {
        int val;
        int originalIdx;
        public Element(int val, int originalIdx) {
            this.val = val;
            this.originalIdx = originalIdx;
        }
    }

    public List<Integer> countSmaller(int[] nums) {
        int n = nums.length;
        List<Integer> res = new ArrayList<>();
        if (n <= 1) {
            res.add(0);
            return res;
        }
        int[] result = new int[n];
        Element[] newNums = new Element[n];
        for (int i = 0; i < n; i++) {
            newNums[i] = new Element(nums[i], i);
        }
        mergeSort(newNums, result, new Element[n], 0, n - 1);
        for (int i = 0; i < n; i++) {
            res.add(result[i]);
        }
        return res;
    }

    public void mergeSort(Element[] nums, int[] result, Element[] tmp, int start, int end) {
        if (start < end) {
            int mid = start + (end - start) / 2;
            mergeSort(nums, result, tmp, start, mid);
            mergeSort(nums, result, tmp, mid+1, end);
            merge(nums, result, tmp, start, end);
        }
    }

    public void merge(Element[] nums, int[] result, Element[] tmp, int start, int end) {
        if (start >= end) return ;
        int mid = start + (end - start) / 2;
        int left = start;
        int right = mid + 1;
        int numberElementsInRightSubArrayThatIsLessThanAllElementsInLeftSubArray = 0;
        int index = start;
        while (left <= mid && right <= end) {
            if (nums[right] < nums[left]) {
                numberElementsInRightSubArrayThatIsLessThanAllElementsInLeftSubArray++;
                tmp[index++] = nums[right++];
            }
            else {
                // right >= left
                result[nums[left].originalIdx] += numberElementsInRightSubArrayThatIsLessThanAllElementsInLeftSubArray;
                tmp[index++] = nums[left++];
            }
        }
        while (left <= mid) {
            result[nums[left].originalIdx] += numberElementsInRightSubArrayThatIsLessThanAllElementsInLeftSubArray;
            tmp[index++] = nums[left++];
        }
        while (right <= end) {
            tmp[index++] = nums[right++];
        }
        for (int i = left; i <= end; i++) {
            nums[i] = tmp[i];
        }
    }
}
```

# Complexity Analysis

Time Complexity: O(N)

Space Complexity: O(N)
